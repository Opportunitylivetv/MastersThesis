\chapter{Extension to Multiple Particles}

We now present an extension of this work for draining multiple particles out of a workpiece. The initial adaption to our approach is fairly trivial, but the two heuristics we present dramatically improve search performance without sacrificing optimality.

\section{Initial Adaption}




\section{Multiple Particle Runtime}

The adaption of this work for multiple particles is fairly trivial to do in the naive implementation. The main difference is now the state is a tuple of concave vertices, one for each particle:

\myequation{
  (V_{cc}^{1}, V_{cc}^{2}, V_{cc}^{3}, ... , V_{cc}^{n})
} {
  \label{eq:multipleParticleStateSpace}
}

Now at each state there are several sets of ``turns'' to sample from, one set for each concave vertex that contains a particle. When a turn is simulated, all other particles must be simulated as well. If any of these particles experiences scenario \#4, the entire sample has to be rejected.

The main disadvantage this naive implementation has is that now the runtime is exponential in the number of concave vertices $n$, as seen in \eqref{eq:bigo}.

\myequation{
O(S \cdot E^2 \cdot V_{cc}^{n})
} {
  \label{eq:bigoTotal}
}

\section{State Hashing for Graph Search Implementation}


\section{Min Pocket Action Space Heuristic}

% figures

\section{Plan Ranking Heuristic}

% first sort by numOutside

% then sort by -10 * numSame + time

