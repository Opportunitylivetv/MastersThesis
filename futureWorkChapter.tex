          \chapter{Results \& Future Work}\label{results}


\section{Online Demo}

Our implementation of this paper and a small solution demonstration is available online at the following url (Mozilla Firefox, Google Chrome, or Apple Safari recommended for full compatibility):

\vspace{0.2in}

\begin{centering}
\url{http://petercottle.com/liquidGraph/index.html?demo}
\end{centering}

\vspace{0.2in}

Another solution demonstration for a more complex part is available at this url:

\vspace{0.2in}

\begin{centering}
\url{http://petercottle.com/liquidGraph/yc.html?demo}
\end{centering}

\vspace{0.2in}


\newpage


\myfigure{width=0.85\linewidth}{demoFoundSolution}{A screen capture from our implementation, available online.}


This implementation includes a visualization that draws the sampling at each vertex and each particle's full path. It includes a graphical user interface for inputting and editing workpiece geometry. Lastly, it also animates the solution search process and the final result; consequently, our implementation of this algorithm runs asynchronously and is called in-between graphical frame draws.

  \subsection{Run Time}

Because our implementation is run asynchronously and performs a lot of graphics processing during the solution search process solely for visualization, we provide both absolute time benchmarks and percentage breakdowns of CPU time between high-level functions.

The following CPU profile was collected during a solution search on a workpiece with 180 total vertices, 55 concave vertices, and 21 polygons. The solution was obtained in 14.64 seconds on a Macbook Air with a 1.86 GHz Intel Core 2 Duo and 2 GB of 1067 MHz DDR3 ram. This time, however, was obtained while a CPU profiler was running (in addition to other applications) and is not representative of the typical runtime for the algorithm.

In fact, search for the solution is rate-limited by the animation engine which runs at 60 frames per second. Consequently, all computers that are capable of completing the necessary operations between frame draws will find the solution in the same amount of time, another reason why absolute computation time is not representative of performance for our work.

The following breakdown on CPU time is provided to get a sense of the computation workload for each high-level function. CPU Self time is defined as the time spent inside the function; CPU total time is defined as the time spent inside that function and the functions called from that location.

\begin{table}[H]
\centering
\label{resultsTable}
\begin{tabular}{|c|c|c|}
\hline
CPU Self Time & CPU Total Time & Function \\ \hline
46.08\% & 46.08\% & Program (total time spent processing in Javascript) \\
20.61\% & 21.35\% & Graphical path generation \& painting \\
1.7\% & 2.8\% & Edge-Parabola intersection \\
0.63\% & 0.64\% & Quadratic equation solver \\
0.30\% & 0.30\% & Edge-Point containment test \\
0.07\% & 0.38\% & Particle sliding equation \\
0.07\% & 0.11\% & Particle collision \\
0.05\% & 3.83\% & Gravity turn sampling \\
0.03\% & 48.74\% & Graph search step \\
\hline
\end{tabular}
\caption{CPU Time breakdown for a solution search}
\end{table}

An important note here is that only 46.08\% of execution time was spent doing computation; the rest was idle time used for animation.

  \subsection{Ranking Heuristic Performance Improvement}

Our plan ranking heuristic presented in Chapter \ref{multipleExtension} produced great performance improvements during multiple-particle search. Here we present a table summarizing the running time difference between a our implementation with and without this plan heuristic.

\begin{table}[H]\label{rankingHeuristicResults}
\centering
\begin{tabular}{|c|c|c|c|c|}
\hline
Test Piece URL & Number of Particles & Time without Ranking Heuristic & Time with Ranking Heuristc & Factor Improvement \\ \hline
$/index.html?demo$ & 4 & 20.672s & 7.009s & 2.949 \\ \hline
$/yc.html?demo$ & 2 & 100.947s & 62.104s & 1.625 \\ \hline
\end{tabular}
\end{table}

  \subsection{Constants}

Our implementation uses the following values for simulation constants:

\begin{table}[H]\label{constantsTable}
\centering
\begin{tabular}{|c|c|c|}
\hline
Constant Description & Symbol & Value \\ \hline
Particle Elasticity & $\kappa$ & 0.5 \\
Perpendicular Edge Velocity & $\epsilon$ & 0.9\\ \hline
\end{tabular}
\end{table}


  \subsection{Scenario \#4 Rejection}

Our preliminary tests indicate that our restriction on scenario \#4 during simulation does not have a large effect on obtaining a solution. While we are not able to determine if workpieces exist in which every solution contains a scenario \#4 particle path, we present a summary of the number of samples rejected due to this restriction below in Table \ref{scenario4rejects}.

\begin{table}[H]\label{scenario4rejects}
\centering
\begin{tabular}{|c|c|c|c|}
\hline
Test Piece URL & Total Samples & Scenario \#4 Samples Rejected & Percentage \\ \hline
$/index.html?demo$ & 3400 & 854 & 25.12\%\\
$/yc.html?demo$ & 1200 & 264 & 22\% \\ \hline
\end{tabular}
\end{table}

It is also important to note that manufacturers may prioritize obtaining \emph{any} solution to the draining problem in a reasonable amount of time over obtaining \emph{the} optimal solution (at the expense of time). If this is the case, it is reasonable to reject scenario \#4 for performance reasons.

\section{Future Work \& Discussion}

Further optimizations and improvements could be made to this work, namely to enhance the usability of the results and increase efficiency.

  \subsection{Heuristics for A* Search}

One standard improvement to uniform cost search is the addition of a consistent, admissible heuristic to convert the search into A* search. A heuristic is simply an estimation of the remaining cost from a state to the goal state. Admissibility of a heuristic requires that the heuristic never over-estimates the remaining cost, and consistency requires that the heuristic does not rapidly change values between states.

Heuristics are, by nature, very dependent on the problem they are being applied to. Many heuristics exist for positional search problems and other common search formulations; since our search formulation is rather unique, there is not as much prior work to draw from \cite{christofides1976worst}.

One initial idea for a heuristic would be to use the free-fall time from the current concave vertex to the outside of the workpiece bounding box. This essentially would be the optimistic estimation that the particle would free-fall immediately from the concave vertex at the next turn. While this heuristic would be admissible and consistent, it does not take into account workpiece geometry; consequently, the information. It is probable that better heuristics exist for this search formulation.

  \subsection{Bounding Box Method Adaption for Particle Path Intersections}

When intersecting rays with geometric primitives, most implementations using bounding-box methods to reduce the number of primitives tested against the ray. This bounding-box idea could be adapted to parabolic paths as well; determining which bounding boxes are needed still presents a fairly reasonable computational load, but great gains in efficiency could be made for complex input with many edges.

  \subsection{Adaption to 3D - Fixed Axis}

Adapting this work to 3D polygonal meshes when the rotation axis of the workpiece is fixed is mainly an exercise in implementation. The primary difference is that parabolic paths would then need to be intersected with planes in 3D space rather than edges in 2D space.

The rest of the approach, from solution search to particle simulation, would remain the same.

  \subsection{Adaption to 3D - Free Axis}

Adapting this work to 3D polygonal meshes where the workpiece can rotate about \emph{any} rotation axis at any time presents a substantially more difficult problem. The chief obstacle here is that there is an explosion of possible turns available from any given concave vertex. The final gravity vector of the turn, $g_{end}$, could be sampled from an entire sphere rather than two small arcs in a planar circle.

There may be ways to intelligently reduce the sample space and still maintain a representative coverage of the kinetic paths attainable from a concave vertex, but much work is needed before those methods can be validated.

